# 所有権と借用

このセクションでは、Rustのメモリ管理の中心である所有権と借用について詳しく説明します。

## 所有権

Rustでは、各値は1つの所有者を持ちます。この所有権の仕組みにより、メモリ管理が安全かつ効率的に行われます。

- **所有者のスコープ**:
  - 所有者がスコープを抜けると、その値は自動的に破棄されます。
  ```rust
  {
      let s = String::from("hello"); // sが所有者
  } // ここでsはスコープを抜け、メモリが解放される
  ```

- **所有権のルール**:
  1. 各値は1つの所有者を持つ。
  2. 所有者がスコープを抜けると値は破棄される。

## 借用

借用は、所有権を移動させずに値を参照する仕組みです。Rustでは、不変借用と可変借用の2種類があります。

- **不変借用**:
  - 値を変更せずに参照します。
  ```rust
  let s = String::from("hello");
  let r1 = &s; // 不変借用
  println!("{}", r1);
  ```

- **可変借用**:
  - 値を変更するための参照です。ただし、同時に複数の可変借用は許可されません。
  ```rust
  let mut s = String::from("hello");
  let r2 = &mut s; // 可変借用
  r2.push_str(", world");
  println!("{}", r2);
  ```

- **借用のルール**:
  1. 不変借用と可変借用を同時に行うことはできない。
  2. 可変借用は1つだけ許可される。

## 所有権の移動

所有権は、値が関数に渡されたり、別の変数に代入されたりする際に移動します。

- **所有権の移動例**:
  ```rust
  let s1 = String::from("hello");
  let s2 = s1; // s1の所有権がs2に移動
  // println!("{}", s1); // エラー: s1はもう有効ではない
  ```

- **関数呼び出しでの所有権移動**:
  ```rust
  fn takes_ownership(s: String) {
      println!("{}", s);
  }

  let s = String::from("hello");
  takes_ownership(s); // sの所有権が関数に移動
  // println!("{}", s); // エラー: sはもう有効ではない
  ```

## 所有権と借用の活用

所有権と借用を理解することで、Rustのメモリ管理を効率的に活用できます。これにより、メモリリークやデータ競合を防ぎ、安全なプログラムを構築できます。
