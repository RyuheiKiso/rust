# ライフタイム

このセクションでは、Rustのライフタイムについて詳しく説明します。

## ライフタイムの基本

ライフタイムは、参照が有効である期間を示します。Rustのコンパイラは、ライフタイムを静的に解析し、不正な参照を防ぎます。

- **ライフタイムの役割**:
  - メモリ安全性を保証するために、参照が有効な期間を明確にします。
  - ダングリングポインタ（無効なメモリ参照）を防ぎます。

- **例**:
  ```rust
  {
      let r;
      {
          let x = 5;
          r = &x; // エラー: xのライフタイムがrより短い
      }
      println!("r: {}", r);
  }
  ```

## ライフタイム注釈

ライフタイム注釈は、参照の有効期間を明示的に指定するために使用されます。注釈は`'a`のようにアポストロフィと識別子で表されます。

- **基本構文**:
  ```rust
  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
      if x.len() > y.len() {
          x
      } else {
          y
      }
  }
  ```
  - この例では、`x`と`y`のライフタイムが同じであることを示しています。

- **複数のライフタイム**:
  ```rust
  fn first_word<'a, 'b>(s1: &'a str, s2: &'b str) -> &'a str {
      s1
  }
  ```
  - 異なるライフタイムを持つ参照を扱うことも可能です。

## ライフタイムの省略

Rustでは、いくつかのケースでライフタイム注釈を省略できます。これを「ライフタイム省略規則」と呼びます。

- **省略規則**:
  1. 各入力ライフタイムは、それぞれ独自のライフタイムパラメータを持つ。
  2. 1つだけの入力ライフタイムがある場合、それがすべての出力ライフタイムに適用される。
  3. メソッドの場合、`self`のライフタイムがすべての出力ライフタイムに適用される。

- **例**:
  ```rust
  fn first_word(s: &str) -> &str {
      &s[0..1]
  }
  ```
  - この場合、ライフタイム注釈は省略されていますが、コンパイラが自動的に推論します。

## ライフタイムと構造体

ライフタイムは構造体にも適用できます。これにより、構造体内の参照が有効である期間を保証します。

- **例**:
  ```rust
  struct ImportantExcerpt<'a> {
      part: &'a str,
  }

  impl<'a> ImportantExcerpt<'a> {
      fn level(&self) -> i32 {
          3
      }
  }
  ```

ライフタイムを理解することで、Rustのメモリ安全性をさらに深く活用できます。
